package com.lzh.compiler.parceler.processor.factory;

import com.lzh.compiler.parceler.processor.model.Constants;
import com.lzh.compiler.parceler.processor.model.FieldData;
import com.lzh.compiler.parceler.processor.util.UtilMgr;
import com.lzh.compiler.parceler.processor.util.Utils;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.ParameterSpec;
import com.squareup.javapoet.ParameterizedTypeName;
import com.squareup.javapoet.TypeName;
import com.squareup.javapoet.TypeSpec;

import java.io.IOException;
import java.util.List;

import javax.lang.model.element.Modifier;
import javax.lang.model.element.TypeElement;

public class ClassFactory {

    List<FieldData> list;
    TypeElement type;

    public ClassFactory (List<FieldData> list, TypeElement type) {
        this.list = list;
        this.type = type;
    }

    public void generateCode () throws IOException {
        // create package and class name of generating class
        String packName = Utils.getPackageName(type);
        String clzName = type.getQualifiedName().toString();
        clzName = Utils.isEmpty(packName) ? clzName + Constants.INJECTOR_SUFFIX
                : clzName.substring(packName.length() + 1).replace(".","$") + Constants.INJECTOR_SUFFIX;

        TypeName superTypeName = ParameterizedTypeName.get(Constants.CLASS_INJECTOR,TypeName.get(type.asType()));
        TypeSpec.Builder classBuidler = TypeSpec.classBuilder(clzName)
                .addModifiers(Modifier.PUBLIC)
                .addSuperinterface(superTypeName);

        MethodSpec.Builder toEntity = MethodSpec.methodBuilder(Constants.METHOD_TO_ENTITY)
                .addAnnotation(Override.class)
                .addModifiers(Modifier.PUBLIC)
                .returns(TypeName.VOID)
                .addParameter(ParameterSpec.builder(TypeName.get(type.asType()), "target").build())
                .addParameter(ParameterSpec.builder(Constants.CLASS_BUNDLE, "data").build())
                .addStatement("Object obj = null");

        MethodSpec.Builder toBundle = MethodSpec.methodBuilder(Constants.METHOD_TO_BUNDLE)
                .addAnnotation(Override.class)
                .addModifiers(Modifier.PUBLIC)
                .returns(TypeName.VOID)
                .addParameter(ParameterSpec.builder(TypeName.get(type.asType()), "target").build())
                .addParameter(ParameterSpec.builder(Constants.CLASS_BUNDLE, "data").build());

        for (FieldData fieldData : list) {
            completeInjectToTarget(toEntity,fieldData);
            completeInjectToBundle(toBundle,fieldData);
        }

        toEntity.addStatement("$T.getParentInjectorByClass($T.class).toEntity(target, data)", Constants.CLASS_PARCELER, TypeName.get(type.asType()));
        toBundle.addStatement("$T.getParentInjectorByClass($T.class).toBundle(target, data)", Constants.CLASS_PARCELER, TypeName.get(type.asType()));

        classBuidler.addMethod(toEntity.build());
        classBuidler.addMethod(toBundle.build());
        JavaFile.Builder builder = JavaFile.builder(packName, classBuidler.build());
        builder.addFileComment("The class is generated by Parceler,do not modify!");
        JavaFile build = builder.build();

        build.writeTo(UtilMgr.getMgr().getFiler());
    }

    private void completeInjectToBundle(MethodSpec.Builder injectToBundle, FieldData fieldData) {
        TypeName fieldType = TypeName.get(fieldData.getVar().asType());
        String fieldName = fieldData.getVar().getSimpleName().toString();
        boolean unBoxType = isUnBoxType(fieldType);
        if (!unBoxType) {
            if (fieldData.isPrivate()) {
                injectToBundle.beginControlFlow("if (target.$N() != null)",Utils.combineGetMethodName(fieldName))
                        .addStatement("data.$N($S,target.$N())",fieldData.getMethodName(),fieldData.getKey(),Utils.combineGetMethodName(fieldName))
                        .endControlFlow();
            } else {
                injectToBundle.beginControlFlow("if (target.$N != null)",fieldName)
                        .addStatement("data.$N($S,target.$N)",fieldData.getMethodName(),fieldData.getKey(),fieldName)
                        .endControlFlow();
            }
        } else {
            if (fieldData.isPrivate()) {
                injectToBundle.addStatement("data.$N($S,target.$N())",fieldData.getMethodName(),fieldData.getKey(),Utils.combineGetMethodName(fieldName));
            } else {
                injectToBundle.addStatement("data.$N($S,target.$N)",fieldData.getMethodName(),fieldData.getKey(),fieldName);
            }
        }
    }

    private void completeInjectToTarget(MethodSpec.Builder injectToData, FieldData fieldData) {
        TypeName fieldType = TypeName.get(fieldData.getVar().asType());
        String fieldName = fieldData.getVar().getSimpleName().toString();
        if (isUnBoxType(fieldType)) {
            injectToData.beginControlFlow("if ((obj = data.get($S)) != null)",fieldData.getKey());
        } else {
            injectToData.beginControlFlow("if ((obj = data.get($S)) != null && (obj = $T.wrapCast(obj, $N.class)) != null)",fieldData.getKey(),Constants.CLASS_UTILS,fieldData.getCastName());
        }

        if (fieldData.isPrivate()) {
            injectToData.addStatement("target.$N(($T)obj)",Utils.combineSetMethodName(fieldName),fieldData.getVar());
        } else {
            injectToData.addStatement("target.$N = ($T)obj",fieldData.getVar().getSimpleName(),fieldData.getVar());
        }
        injectToData.endControlFlow();
        if (fieldData.isNonNull()) {
            injectToData.beginControlFlow("else")
                    .addStatement("throw new $T(\"Field $N in $N has requires non-null\")",IllegalArgumentException.class,fieldData.getVar().getSimpleName(),type.getSimpleName())
                    .endControlFlow();
        }

    }

    TypeElement getClassByName (String clzName) {
        return UtilMgr.getMgr().getElementUtils().getTypeElement(clzName);
    }

    TypeName getTypeNameByName (String clzName) {
        return TypeName.get(getClassByName(clzName).asType());
    }

    TypeName unBoxTypeName (TypeName name) {
        if (name.isBoxedPrimitive()) {
            return name.unbox();
        }
        return name;
    }

    boolean isUnBoxType(TypeName name) {
        switch (name.toString()) {
            case "boolean":
            case "byte":
            case "char":
            case "short":
            case "int":
            case "long":
            case "float":
            case "double":
                return true;
        }
        return false;
    }
}
